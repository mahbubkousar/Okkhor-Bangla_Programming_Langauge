# tests/test_ir_to_bytecode.py
import unittest
from src.vm.ir_to_bytecode import IRToBytecodeGenerator


class TestIRToBytecodeGenerator(unittest.TestCase):

    def test_generate_bytecode(self):
        # Example IR statements to be converted to bytecode
        ir_statements = [
            {"type": "assign", "variable": "a", "value": 5},
            {"type": "assign", "variable": "b", "value": 10},
            {"type": "add", "left_operand": "a", "right_operand": "b"},
            {"type": "assign", "variable": "result", "value": 0},
        ]

        # Initialize the generator and generate the bytecode
        generator = IRToBytecodeGenerator()
        generator.generate(ir_statements)
        bytecode = generator.get_bytecode()

        # Expected bytecode for the given IR
        expected_bytecode = [
            ("PUSH", 5),
            ("STORE", "a"),
            ("PUSH", 10),
            ("STORE", "b"),
            ("PUSH", "a"),
            ("PUSH", "b"),
            ("ADD",),
            ("STORE", "result"),
        ]

        # Assert that the generated bytecode matches the expected bytecode
        self.assertEqual(bytecode, expected_bytecode)

    def test_edge_case_empty_ir(self):
        # Test case where the IR is empty
        ir_statements = []
        generator = IRToBytecodeGenerator()
        generator.generate(ir_statements)
        bytecode = generator.get_bytecode()

        # The expected bytecode should be an empty list
        self.assertEqual(bytecode, [])

    def test_single_assignment(self):
        # Test case with a single assignment IR
        ir_statements = [{"type": "assign", "variable": "a", "value": 100}]
        generator = IRToBytecodeGenerator()
        generator.generate(ir_statements)
        bytecode = generator.get_bytecode()

        expected_bytecode = [
            ("PUSH", 100),
            ("STORE", "a"),
        ]

        self.assertEqual(bytecode, expected_bytecode)


if __name__ == '__main__':
    unittest.main()
